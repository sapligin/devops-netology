# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

## Решение:

В MongoDB Shell определяем операцию, которая продолжается больше 3 минут (180 секунд) командой:  
```
db.currentOp({"secs_running": {$gte: 180}})
```
Завершаем операцию по `opid` командой:
```
db.killOp()
```
Для решения проблемы с долгими запросами нужно убедиться, что используются индексы для работы с данными.  
Запросы, не использующие индексы увеличивают потребление I/O (чтений с диска будет больше), и CPU (если данные сжаты, так как для них требуется декомпрессия).  
Если индексы существуют, то возможно необходимо добавить дополнительные индексы для большей эффективности.

## Задача 2

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

## Решение:
Так как используется сервис с механизмом TTL, то возможно, проблема в том, что ключи, срок действия которых истекает в один и тот же момент, могут быть источником задержки.

В документации Redis по уменьшению задержки сказано: алгоритм удаления ключей с истекшим TTL зациклится, если обнаружит, что более 25% ключей уже просрочены в наборе выбранных ключей. Но, учитывая, что мы запускаем алгоритм десять раз в секунду, это означает, что срок действия более чем 25% ключей в нашей случайной выборке истекает как минимум в одну и ту же секунду .

В основном это означает, что **если в базе данных есть много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, Redis может заблокировать операции**, чтобы получить процент ключей, срок действия которых истек ниже, чем 25%.

Так как Redis - однопоточное приложение, то все операции блокируются, пока он не выполнит очистку.

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

## Решение:
Исходя из документации MySQL и того, что возросло количество записей в таблицах базы, то проблемы и их решение следующие:

Обычно это указывает на проблемы с подключением к сети, и необходимо проверить состояние сети, если эта ошибка возникает часто. Если сообщение об ошибке включает «во время запроса», это, вероятно, проблема с сетью.

Иногда форма «во время запроса» возникает, когда миллионы строк отправляются как часть одного или нескольких запросов. В этом случае необходимо увеличить значение параметра `net_read_timeout` с 30 секунд до 60 секунд или дольше, что достаточно для завершения передачи данных.

## Задача 4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

## Решение:
Проблема в нехватке оперативной памяти.

Когда памяти на сервере не хватает, OOM-killer вызывает и уничтожает процесс PostgreSQL.

Если нет возможности увеличить память на сервере, то необходимо настраивать параметры PostgreSQL:
- `shared_buffer` - этот параметр устанавливает, сколько выделенной памяти будет использоваться PostgreSQL для кеширования.
- `wal_buffers` - PostgreSQL сначала записывает записи в WAL (журнал предзаписи) в буферы, а затем эти буферы сбрасываются на диск. Размер буфера по умолчанию, определенный `wal_buffers`, составляет 16 МБ. Если к базе данных много одновременных подключений, то более высокое значение может повысить производительность.
- `work_mem` - эта настройка используется для сложной сортировки. Установка очень высокого значения может стать причиной узкого места в памяти, поскольку этот параметр относится к операции сортировки пользователя. Установка этого параметра глобально может привести к очень высокому использованию памяти.
- `maintenance_work_mem` - эта настройка используется для определения используемого объема памяти, используемой для задач обслуживания базы данных. Необходимо устанавливать данный параметр выше, чем параметр `work_mem`.
- `effective_cache_size` - оценивает, сколько памяти доступно для кэширования диска операционной системой и самой базой данных. Рекомендуется устанавливать `effective_cache_size` равным 50% от общего объема оперативной памяти компьютера.